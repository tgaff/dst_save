
gemrun("addpermodconfig", GEMENV.modname, "MemSpikeFix", {
    hover = "Control whether this mod gets memspikefixed or not. Each mod can override its config option.",
    options = {
        {
            description = "Enable",
            data = true,
            hover = "Disable memspikefix for this mod."
        },
        {
            description = "Default",
            data = "default",
            hover = "Let the master switch control whether this mod gets memspikefixed."
        },
        {
            description = "Disable",
            data = false,
            hover = "Disable memspikefix for this mod.",
        },
    }, 
    default = "default",
},
{
    master_override = {
        options = {
            {
                description = "Enable",
                data = true,
                hover = "Enable memspikefix by default for all mods."
            },
            {
                description = "Disable",
                data = false,
                hover = "Disable memspikefix by default for all mods."
            },
        },
        default = true,
    },
    exclude_self = true,
    --server_only = true,
})


if TheFrontEnd then return end

local forcedmemspikefix = {}
local MakeGemFunction = gemrun("gemfunctionmanager")
MakeGemFunction("forcememspikefix", function(functionname, force, ...)
    local env = getfenv(3)
    if env and env.modname and type(force) == "boolean" then
        forcedmemspikefix[env.modname] = force
    end
end, true)

--Thanks NSimplex!

--[[
-- Receives a Prefab object, and tweaks its entity constructor ("fn") to
-- make the prefab be loaded before it is spawned.
--]]

local replacedfns = {}
local _getupvalue = debug.getupvalue
function debug.getupvalue(fn, ...)
    return _getupvalue(replacedfns[fn] or fn, ...)
end
local function MakeLazyLoader(prefab)
	if prefab.fn then
		local fn = prefab.fn
		local current_fn

		local function new_fn(...)
            TheSim:UnloadPrefabs({prefab.name})
			TheSim:LoadPrefabs({prefab.name})

			-- Ensures this only runs once, for efficiency.
			current_fn = fn

			return fn(...)
		end

		current_fn = new_fn

		--[[
		-- This extra layer of indirection ensures greater mod friendliness.
		--
		-- If we just set prefab.fn to new_fn, and later back to fn, we could
		-- end up overriding an fn patch done by another mod. By switching between
		-- the two internally, via the current_fn upvalue, we preserve any such
		-- patching.
		--]]
		prefab.fn = function(...)
			return current_fn(...)
		end
        gemrun("hidefn", prefab.fn, fn)
        replacedfns[prefab.fn] = fn
	else
		--Prefab's without a .fn get loaded immediatly, since its just assets for Skins
        TheSim:UnloadPrefabs({prefab.name})
		TheSim:LoadPrefabs({prefab.name})
	end
end

------------------------------------------------------------------------

local ModMananger_RegisterPrefabs = ModManager.RegisterPrefabs
function ModManager.RegisterPrefabs(self, ...)
    local _RegisterPrefabs = RegisterPrefabs

    local mod_prefabnames = {}

    RegisterPrefabs = function(...)
        for _, prefab in ipairs({...}) do
            local moddir = prefab.name:match("^MOD_(.+)$")
            if moddir then
                local memspikefix = true
                local modforce = forcedmemspikefix[moddir]

                if modforce ~= nil then
                    memspikefix = modforce
                else
                    local config = GetModModConfigData("MemSpikeFix", moddir, GEMENV.modname)--, true)
                    --get_local_config doesn't(and probably won't ever) work for mod configs generated by some mod, since you would need to get code execution on the modsmenu on the client.
                    if config ~= nil then
                        memspikefix = config
                    end
                end

                if memspikefix then
                    --print("MEMFIXING "..moddir)
                    for _, name in ipairs(prefab.deps) do
                        table.insert(mod_prefabnames, name)
                    end

                    prefab.deps = {}
                    --print("Purged deps from "..prefab.name)
                else
                    print("MEMFIXING disabled for mod: "..moddir)
                end
            end
        end
        return _RegisterPrefabs(...)
    end

    ModMananger_RegisterPrefabs(self, ...)

    RegisterPrefabs = _RegisterPrefabs

    -- First, do a pass over recipes to extend dependencies if need be.
    for k, v in pairs(AllRecipes) do
        table.removearrayvalue(mod_prefabnames, v.name)
        if v.placer then
            table.removearrayvalue(mod_prefabnames, v.placer)
        end
    end

    for _, prefabname in ipairs(mod_prefabnames) do
        --print("Registering "..prefabname)
        
        local prefab = Prefabs[prefabname]

        _RegisterPrefabs(prefab)

        MakeLazyLoader(prefab)

        -- This also takes care of the unloading, so there's no need to patch ModWrangler:UnloadPrefabs.
        table.insert(self.loadedprefabs, prefabname)
    end

    --re-reset this with modded recipes.
    RECIPE_PREFABS = {}
    for k,v in pairs(AllRecipes) do
        table.insert(RECIPE_PREFABS, v.name)
        if v.placer then
            table.insert(RECIPE_PREFABS, v.placer)
        end
    end
end
